
import jaci.gradle.toolchains.*
import jaci.gradle.nativedeps.*

plugins {
  id 'cpp'
  id 'c'
  id 'edu.wpi.first.wpilib.repositories.WPILibRepositoriesPlugin' version '2020.2'
  id 'edu.wpi.first.NativeUtils' version '2020.7.1'
  id 'edu.wpi.first.GradleJni' version '0.10.1'
  id 'edu.wpi.first.GradleVsCode' version '0.11.0'
}

apply plugin: 'jaci.gradle.EmbeddedTools'

if (project.hasProperty('releaseMode')) {
  wpilibRepositories.addAllReleaseRepositories(project)
} else {
  wpilibRepositories.addAllDevelopmentRepositories(project)
}

apply from: 'config.gradle'

deploy {
    targets {
        target('roborio') {
            directory = '/home/admin'
            maxChannels = 4
            locations {
                ssh {
                    address = "172.22.11.2"
                    user = 'admin'
                    password = ''
                    ipv6 = false
                }
            }
        }
    }
    artifacts {
        all {
            targets << 'roborio'
            postdeploy << { ctx ->
                ctx.execute("sync")
                ctx.execute("ldconfig")
            }
        }

        fileArtifact('myFileArtifact') {
            file = file('FPGA/FPGA Bitfiles/Generated/NiFpga_OpenSourceRIO.lvbitx')               // Set the file to deploy. Required.
            filename = 'NiFpga_OpenSourceRIO.lvbitx'             // Set the filename to deploy to. Default: same name as file
        }

        nativeArtifact('testStatic') {
            predeploy << { ctx ->
                ctx.execute('/usr/local/frc/bin/frcKillRobot.sh -t')
            }
            component = 'testExe'
            targetPlatform = nativeUtils.wpi.platforms.roborio
            buildType = 'debug'

            postdeploy << { ctx ->
                ctx.execute('chmod +x testExe')
            }
        }
    }
}


model {
  components {
    wpiHal(NativeLibrarySpec) {
      sources {
        fpga(CSourceSet) {
          source {
            srcDirs 'src/main/native/fpga'
            srcDir 'FPGA/FPGA Bitfiles/Generated'
            include '**/*.c'
          }
          exportedHeaders {
            srcDirs 'src/main/native/fpga'
            srcDir 'FPGA/FPGA Bitfiles/Generated'
          }
        }
        c {
          source {
            srcDirs 'src/main/native/c'
            include '**/*.c'
          }
          exportedHeaders {
            srcDirs 'src/main/native/fpga'
            srcDir 'src/main/native/include'
            srcDir 'FPGA/FPGA Bitfiles/Generated'
          }
        }
        cppShared(CppSourceSet) {
          source {
            srcDirs 'src/main/native/cppshared'
            include '**/*.cpp'
          }
          exportedHeaders {
            srcDirs 'src/main/native/fpga'
            srcDir 'src/main/native/include'
            srcDir 'FPGA/FPGA Bitfiles/Generated'
          }
        }
        cpp {
          source {
            srcDirs 'src/main/native/cpp'
            include '**/*.cpp'
          }
          exportedHeaders {
            srcDirs 'src/main/native/fpga'
            srcDir 'src/main/native/include'
            srcDir 'FPGA/FPGA Bitfiles/Generated'
          }
        }
      }
      nativeUtils.useRequiredLibrary(it, 'hal_headers', 'wpiutil_shared', 'visa_shared')
    }

    testExe(NativeExecutableSpec) {
      nativeUtils.excludeBinariesFromStrip(it)
      sources {
        c {
          source {
            srcDirs 'src/main/exe/c'
            include '**/*.c'
          }
        }
      }

      binaries.all {
        lib library: 'wpiHal', linkage: 'static'
        nativeUtils.useRequiredLibrary(it, 'hal_headers', 'ntcore_static', 'wpiutil_static', 'visa_shared', 'ni_runtime_shared')
      }
    }

  }
}


wrapper {
  gradleVersion = '6.0.1'
}

def genInterface = tasks.register('runFPGACGenerator', Exec) {
  workingDir file('FPGA\\FPGA Bitfiles')

  inputs.file file('FPGA\\FPGA Bitfiles\\roboriofpga_OpenSourceRIO_OpenSourceRIO.lvbitx')
  outputs.dir file('FPGA\\FPGA Bitfiles\\GeneratedRaw')

  commandLine 'C:\\Program Files (x86)\\National Instruments\\FPGA Interface C API\\nicapigencli.exe', 'roboriofpga_OpenSourceRIO_OpenSourceRIO.lvbitx', '-e', '--outputDirectory', file('FPGA\\FPGA Bitfiles\\GeneratedRaw')
}

def patchFPGA = tasks.register('patchFPGA') {
  inputs.dir file('FPGA\\FPGA Bitfiles\\GeneratedRaw')
  outputs.dir file('FPGA\\FPGA Bitfiles\\Generated')

  dependsOn genInterface

  doLast {
    def headerFileLines = file('FPGA\\FPGA Bitfiles\\GeneratedRaw\\NiFpga_OpenSourceRIO.h').readLines()
    def srcFileText = file('FPGA\\FPGA Bitfiles\\GeneratedRaw\\NiFpga_OpenSourceRIO.c').text

    def typedefLines = [:]

    // Add static to definitons
    headerFileLines.eachWithIndex { line, index ->
      if (line.startsWith('const')) {
        headerFileLines.set(index, "static ${line}".toString())
      }

      if (line.startsWith('const NiFpga_FxpTypeInfo ')) {
        def key = line.split(' ')[2]
        def lineArr = typedefLines.get(key)
        if (lineArr != null) {
          lineArr << index
        } else {
          lineArr = [index]
          typedefLines.put(key, lineArr)
        }
      }

    }

    def removed = 0

    typedefLines.each { key, value ->
      if (value.size > 1) {
        // Found any duplicates, remove the next 7 lines
        def toRemove = (value.size - 1) * 6
        def start = value.get(1) - removed
        for (int i = start; i < toRemove + start ; i++) {
          headerFileLines.remove(start)
          removed++
        }
      }
    }



    file('FPGA\\FPGA Bitfiles\\Generated\\NiFpga_OpenSourceRIO.h').text = headerFileLines.join(System.properties.'line.separator')
    file('FPGA\\FPGA Bitfiles\\Generated\\NiFpga_OpenSourceRIO.c').text = srcFileText



    copy {
      from 'FPGA\\FPGA Bitfiles\\GeneratedRaw\\NiFpga_OpenSourceRIO.lvbitx'
      into "FPGA\\FPGA Bitfiles\\Generated"
    }
  }
}

tasks.register('generateFPGA') {
  dependsOn genInterface
  dependsOn patchFPGA
}
